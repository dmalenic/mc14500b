#ifndef _MEMORY_MAP_H
#define _MEMORY_MAP_H

#include <Arduino.h>

////////////////////////////////////////////////////////////////////
// Select the application
////////////////////////////////////////////////////////////////////

#define KILLBIT       0
#define SERIAL_HELLO  0
#define TIMER_TEST    0
#define SWITCH_TOGGLE 0
#define CONWAY_GOL    1 


////////////////////////////////////////////////////////////////////
// RAM
////////////////////////////////////////////////////////////////////

#define MEMORY_START  ((word) 0b0000)
#define MEMORY_END    ((word) 0b0111)
byte MEMORY[MEMORY_END-MEMORY_START+1];

// 000000r 2               MEM0 = $0
// 000000r 2               MEM1 = $1
// 000000r 2               MEM2 = $2
// 000000r 2               MEM3 = $3
// 000000r 2               MEM4 = $4
// 000000r 2               MEM5 = $5
// 000000r 2               MEM6 = $6
// 000000r 2               MEM7 = $7
// 000000r 2               
// 000000r 2               RR = $8      // RR bit instead of IN0 !!
// 000000r 2               IN1 = $9
// 000000r 2               IN2 = $A
// 000000r 2               IN3 = $B
// 000000r 2               IN4 = $C
// 000000r 2               IN5 = $D
// 000000r 2               IN6 = $E
// 000000r 2               IN7 = $F
// 000000r 2               
// 000000r 2               OUT0 = $8
// 000000r 2               OUT1 = $9
// 000000r 2               OUT2 = $A
// 000000r 2               OUT3 = $B
// 000000r 2               OUT4 = $C
// 000000r 2               OUT5 = $D
// 000000r 2               OUT6 = $E
// 000000r 2               OUT7 = $F

////////////////////////////////////////////////////////////////////
// ROM
////////////////////////////////////////////////////////////////////
// Convert bin to hex at http://tomeko.net/online_tools/file_to_hex.php?lang=en

// ROMs
#define ROM_START           ((word) 0x0000)
#define ROM_END             ((word) (ROM_START+sizeof(rom_bin)-1))
#define ROM                 rom_bin

////////////////////////////////////////////////////////////////////
// Monitor Code
////////////////////////////////////////////////////////////////////
#define STORE_ROM_IN_FLASH  0  // 0: Save ROM in RAM, 1: Save ROM in FLASH (uneditable in shell)


#if STORE_ROM_IN_FLASH
const unsigned char rom_bin[] PROGMEM = {
#else
unsigned char rom_bin[] = {
#endif

#if KILLBIT   // Killbit Image (regression test that my changes do not break the most important application)
              // Note, the first 16 bytes has changed a from the version in k14500b_kilbit.ino,
              // though the semantics is preserved,
              // see Note in Processor Control Loop in k14500b_1d_conway_gol.ino for the explanation of the changes. 
//   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
  0xF2, 0xCF, 0xF4, 0xD0, 0xF6, 0xD0, 0xF8, 0xD0, 0xFA, 0xD0, 0xFC, 0xD0, 0xFE, 0xD0, 0xD0, 0xFE,   // Without external LUT (see k14500b_roll_a_die), JSR/JMP/RTN only work in this range due to 4bit memory:)
  0x80, 0x68, 0xA8, 0x10, 0x28, 0xB8, 0x81, 0x68, 0xB8, 0x11, 0x89, 0x12, 0x8A, 0x13, 0x8B, 0x14, 
  0x8C, 0x15, 0x8D, 0x16, 0x8E, 0x17, 0x8F, 0x19, 0x71, 0x91, 0x1A, 0x72, 0x92, 0x1B, 0x73, 0x93, 
  0x1C, 0x74, 0x94, 0x1D, 0x75, 0x95, 0x1E, 0x76, 0x96, 0x1F, 0x77, 0x97, 0x16, 0x80, 0x15, 0x86, 
  0x10, 0x85, 0x15, 0x80, 0x14, 0x85, 0x10, 0x84, 0x14, 0x80, 0x13, 0x84, 0x10, 0x83, 0x13, 0x80, 
  0x12, 0x83, 0x10, 0x82, 0x12, 0x80, 0x11, 0x82, 0x10, 0x81, 0x11, 0x80, 0x10, 0x81, 0x10, 0x80, 
  0x17, 0x80, 0x11, 0x87, 0x10, 0x81, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF

#elif SERIAL_HELLO   // Hello world to serial port P0 (see k14500b_serial_hell - this is also a regression test)
//   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
  0x68, 0xA8, 0xB8, 0x68, 0x88, 0x98, 0x98, 0x98, 0x98, 0x88, 0x98, 0x98, 0x88, 0x98, 0x88, 0x00, 
  0x98, 0x88, 0x98, 0x88, 0x98, 0x98, 0x88, 0x88, 0x98, 0x88, 0x00, 0x98, 0x98, 0x98, 0x88, 0x88, 
  0x98, 0x88, 0x88, 0x98, 0x88, 0x00, 0x98, 0x98, 0x98, 0x88, 0x88, 0x98, 0x88, 0x88, 0x98, 0x88, 
  0x00, 0x98, 0x88, 0x88, 0x88, 0x88, 0x98, 0x88, 0x88, 0x98, 0x88, 0x00, 0x98, 0x88, 0x88, 0x88, 
  0x98, 0x88, 0x98, 0x88, 0x98, 0x88, 0x00, 0x98, 0x88, 0x88, 0x88, 0x88, 0x98, 0x88, 0x88, 0x98, 
  0x88, 0x00, 0x98, 0x98, 0x88, 0x98, 0x98, 0x88, 0x88, 0x88, 0x98, 0x88, 0x00, 0x98, 0x98, 0x98, 
  0x88, 0x88, 0x98, 0x88, 0x88, 0x98, 0x88, 0x00, 0x98, 0x98, 0x98, 0x88, 0x98, 0x98, 0x88, 0x88, 
  0x98, 0x88, 0x00, 0x98, 0x88, 0x98, 0x98, 0x98, 0x98, 0x88, 0x98, 0x98, 0x88, 0x00, 0x98, 0x88, 
  0x98, 0x88, 0x88, 0x98, 0x98, 0x98, 0x98, 0x88, 0x00, 0x98, 0x98, 0x88, 0x98, 0x88, 0x98, 0x98, 
  0x98, 0x98, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

#elif TIMER_TEST   // Timer test - a running lights paced by the timer on 2Hz (see timer_emul.h)

//   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
//  0x87, 0x68, 0xA8, 0xB8, 0x17, 0x28, 0xE0, 0x80, 0x1F, 0xE0, 0xC0, 0x10, 0x88, 0x11, 0x89, 0x12,
//  0x8A, 0x13, 0x8B, 0x14, 0x8C, 0x15, 0x8D, 0x16, 0x8E, 0x16, 0x97, 0x15, 0x86, 0x14, 0x85, 0x13,
//  0x84, 0x12, 0x83, 0x11, 0x82, 0x10, 0x81, 0x17, 0x80, 0x68, 0x8F, 0x9F, 0xC0, 0x00, 0x00, 0x00,
  0x87, 0x68, 0xA8, 0xB8, 0x27, 0xE0, 0x80, 0x1F, 0xE0, 0xC0, 0x10, 0x88, 0x11, 0x89, 0x12, 0x8A,
  0x13, 0x8B, 0x14, 0x8C, 0x15, 0x8D, 0x16, 0x8E, 0x16, 0x97, 0x15, 0x86, 0x14, 0x85, 0x13, 0x84,
  0x12, 0x83, 0x11, 0x82, 0x10, 0x81, 0x17, 0x80, 0x68, 0x8F, 0x9F, 0xC0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

#elif SWITCH_TOGGLE  // test if IN1..IN6 can be used as toggle switches (see toggle_swithc.h)

//   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
  0x68, 0xA8, 0xB8, 0x19, 0x89, 0x1A, 0x8A, 0x1B, 0x8B, 0x1C, 0x8C, 0x1D, 0x8D, 0x1E, 0x8E, 0x1F,
  0x8F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

#elif CONWAY_GOL     // 1D Conway's Game of Life image
//   0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
  0x68, 0xA8, 0xB8, 0x2E, 0xB8, 0xA8, 0x19, 0x81, 0x89, 0x1A, 0x82, 0x8A, 0x1B, 0x83, 0x8B, 0x1C, 
  0x84, 0x8C, 0x1D, 0x85, 0x8D, 0x68, 0x90, 0x98, 0x96, 0x9E, 0x97, 0x9F, 0x68, 0xB8, 0xA8, 0x2E, 
  0xE0, 0xC0, 0x1F, 0xE0, 0xC0, 0x68, 0x97, 0x27, 0x45, 0x46, 0xA8, 0xB8, 0x10, 0x85, 0x86, 0x87, 
  0x11, 0x80, 0x11, 0x85, 0x86, 0x17, 0x72, 0x91, 0x12, 0x85, 0x13, 0x76, 0x92, 0x13, 0x86, 0x14, 
  0x75, 0x93, 0x14, 0x85, 0x16, 0x84, 0x17, 0x86, 0x17, 0x67, 0x87, 0x68, 0xA8, 0xB8, 0x27, 0x35, 
  0x46, 0xA8, 0xB8, 0x10, 0x85, 0x86, 0x87, 0x11, 0x80, 0x11, 0x85, 0x86, 0x17, 0x72, 0x91, 0x12, 
  0x85, 0x13, 0x76, 0x92, 0x13, 0x86, 0x14, 0x75, 0x93, 0x14, 0x85, 0x26, 0x84, 0x27, 0x86, 0x17, 
  0x67, 0x87, 0x68, 0xA8, 0xB8, 0x27, 0x45, 0x36, 0xA8, 0xB8, 0x10, 0x85, 0x86, 0x87, 0x21, 0x80, 
  0x11, 0x85, 0x86, 0x17, 0x72, 0x91, 0x12, 0x85, 0x13, 0x76, 0x92, 0x13, 0x86, 0x14, 0x75, 0x93, 
  0x14, 0x85, 0x16, 0x84, 0x25, 0x85, 0x17, 0x86, 0x17, 0x67, 0x87, 0x68, 0xA8, 0xB8, 0x27, 0x35, 
  0x36, 0xA8, 0xB8, 0x10, 0x85, 0x86, 0x87, 0x21, 0x80, 0x11, 0x85, 0x86, 0x17, 0x72, 0x91, 0x12, 
  0x85, 0x13, 0x76, 0x92, 0x13, 0x86, 0x14, 0x75, 0x93, 0x14, 0x85, 0x26, 0x84, 0x25, 0x85, 0x27, 
  0x86, 0x68, 0xA8, 0xB8, 0x10, 0x88, 0x11, 0x89, 0x12, 0x8A, 0x13, 0x8B, 0x14, 0x8C, 0x15, 0x8D, 
  0x16, 0x8E, 0x68, 0xB8, 0x8F, 0x9F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

#else

#error "Please select the ROM image to use"

#endif

};

////////////////////////////////////////////////////////////////////
// Used by RetroShell to access ROM
////////////////////////////////////////////////////////////////////

byte rom_read_byte(word addr)
{
  #if STORE_ROM_IN_FLASH
    if ((addr >= ROM_START) && (addr <= ROM_END ))
      return pgm_read_byte_near(ROM + (addr - ROM_START));
    else
      return 0;
  #else
    if ((addr >= ROM_START) && (addr <= ROM_END))
      return ROM[addr - ROM_START];
    else
      return 0;
  #endif
}

bool rom_write_byte(word addr, byte value)
{
  #if STORE_ROM_IN_FLASH
    Serial.println("ERR: Can not update ROM in FLASH.");
    return false;
  #else
    if ((addr >= ROM_START) && (addr <= ROM_END)) 
      ROM[addr - ROM_START] = value;
    return true;
  #endif
}


#endif // _MEMORYMAP_H

